#!/usr/bin/python3
import os
import sys
import stat
import shlex
import pathlib
import hashlib
import itertools
import subprocess

from typing import Optional

try:
    import click
    import yaml
except ImportError as e:
    sys.exit(f"Environment is not configured properly: {e}")


SPEC_ERROR_MARKER = "Spec error"
RUN_CMD_TEMPLATE = "{program} {args}"
SWEEP_CMD_TEMPLATE = (
    # Remove commented and empty lines.
    " grep -o '^[^#]*' {runfile}"
    # Run using GNU parallel.
    " | parallel --bar -j {n_jobs} --joblog={joblog_path} {mode_flag} {parallel_args}"
    # Additional logging for each task.
    "'{{1}} > {log_dir}/{{#}}.out 2> {log_dir}/{{#}}.err'"
)
DEFAULT_LOG_DIR = pathlib.Path("logs")
DEFAULT_JOBLOG_FILENAME = "joblog.txt"
RUNFILE_TEMPLATE = "{spec_name}.runfile"


def get_cmd_arg_str(kwargs):
    """
    >>> get_cmd_arg_str({"alpha": 1, "beta": "val"})
    '--alpha=1 --beta=val'
    """
    return " ".join(f"--{k}={v}" for k, v in kwargs.items())


def generate_commands(spec_name, program, config):
    commands = []
    for parameter_values in itertools.product(*config.values()):
        args = get_cmd_arg_str(dict(zip(config.keys(), parameter_values)))
        program_escaped = program.replace('"', '\\"')
        commands.append(
            RUN_CMD_TEMPLATE.format(
                program=program_escaped,
                args=args,
            )
        )

    return commands


def parse_spec(spec_path):
    """
    Parse specification from a YAML file.
    """
    with open(spec_path, "r") as f:
        spec = yaml.safe_load(f)

    try:
        program = spec["program"]
    except KeyError:
        sys.exit(f"{SPEC_ERROR_MARKER}: executable not specified.")

    try:
        parameters_spec = spec["parameters"]
    except KeyError:
        sys.exit(f"{SPEC_ERROR_MARKER}: parameters not specified.")
    config = {}
    for parameter_name, parameter_section in parameters_spec.items():
        parameter_values = parameter_section.get("values")
        parameter_value = parameter_section.get("value")
        if parameter_values:
            config[parameter_name] = parameter_values
        elif parameter_value:
            config[parameter_name] = [parameter_value]

    return program, config


def create_runfile(spec_path, runfile):
    spec_path = pathlib.Path(spec_path)
    spec_name = spec_path.stem

    program, config = parse_spec(spec_path)
    commands = generate_commands(spec_name, program, config)

    runfile = runfile or RUNFILE_TEMPLATE.format(spec_name=spec_name)
    with open(runfile, "w+") as f:
        f.write("\n".join(commands) + "\n")


@click.group()
def cli():
    pass


@cli.command()
@click.argument("spec", type=click.Path(exists=True))
@click.option(
    "--runfile",
    help="Location for the generated runfile.",
    type=click.Path(exists=False),
    default=None,
)
def init(
    spec,
    runfile,
):
    """
    Initialize a sweep over script parameters in parallel.

    The command generates a runfile containing the commands which are to be
    executed in parallel. Then, it runs each command from the runfile using GNU parallel.

    The command requires a specification YAML file for the search in a format compatible with
    Weights and Biases sweep config.
    """
    create_runfile(spec, runfile)


@cli.command()
@click.argument(
    "config_path",
    type=click.Path(exists=False),
)
@click.option(
    "--mode",
    type=click.Choice(["resume", "resume-failed", "retry-failed", "overwrite"]),
    help="How to deal with previous runs.",
    default="resume",
)
@click.option(
    "-j",
    "--n_jobs",
    help="Number of jobs to execute in parallel. By default is one.",
    type=int,
    default=1,
)
@click.option(
    "--log_dir",
    help="Location for logs. By default is {DEFAULT_LOG_DIR}/<spec_name>",
    type=click.Path(exists=False),
    default=None,
)
@click.option(
    "--joblog_filename",
    help="Filename for the job log.",
    type=str,
    default=DEFAULT_JOBLOG_FILENAME,
)
@click.option(
    "--parallel_args", help="Arguments to pass to GNU parallel.", default=None
)
@click.option(
    "--silent", help="Whether to output messages.", default=False, is_flag=True
)
def sweep(config_path, mode, log_dir, n_jobs, joblog_filename, parallel_args, silent):
    """
    Launch a sweep over a grid for different parameter values.

    The commands takes as input a CONFIG_PATH, which is the location of the spec file or the runfile.
    If it is the spec, it first generates a runfile containing the commands which are to be
    executed in parallel. Then, it runs each command from the runfile using GNU parallel.
    The stem of the CONFIG_PATH is assumed to be the spec name.
    """
    config_path = pathlib.Path(config_path)
    config_ext = config_path.suffix

    # Assuming the config path is the spec.
    if config_ext.lower() in [".yml", ".yaml"]:
        spec_name = config_path.stem
        runfile = pathlib.Path(RUNFILE_TEMPLATE.format(spec_name=spec_name))
        if not silent:
            print(f"Using spec: {config_path}")
            print(f"Generating runfile: {runfile}")
        create_runfile(config_path, runfile=runfile)

    else:
        runfile = config_path
        spec_name = runfile.stem

    # Otherwise, assuming the config path is the runfile.
    if log_dir is None:
        base_log_dir = pathlib.Path.cwd() / DEFAULT_LOG_DIR

    log_dir = base_log_dir / spec_name
    pathlib.Path.mkdir(log_dir, parents=True, exist_ok=True)

    parallel_args = parallel_args or ""
    if mode == "overwrite":
        mode_flag = ""
    else:
        mode_flag = f"--{mode}"

    parallel_cmd = SWEEP_CMD_TEMPLATE.format(
        runner=__file__,
        runfile=runfile,
        n_jobs=n_jobs,
        log_dir=log_dir,
        joblog_path=log_dir / joblog_filename,
        spec_name=spec_name,
        mode_flag=mode_flag,
        parallel_args=parallel_args,
    )

    if not silent:
        print(f"Starting sweep from runfile: {runfile}")
        print(f"Logging to: {log_dir}")
        print(f"Mode: {mode}")
        print(f"Executing: {parallel_cmd}")

    subprocess.call(
        [parallel_cmd],
        shell=True,
    )


if __name__ == "__main__":
    cli()
